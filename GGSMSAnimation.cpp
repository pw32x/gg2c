#include "stdafx.h"
#include "GGSMSAnimation.h"
#include "WriteUtils.h"
#include <fstream>
#include <algorithm>
#include <sstream>

namespace sms
{

GGAnimation::GGAnimation(LPVOID galeFileHandle, const Options& options, AnimationProperties& animationProperties)
: m_galeFileHandle(galeFileHandle),
  m_options(options),
  m_animationProperties(animationProperties)
{
    HBITMAP bitmap = ggGetBitmap(m_galeFileHandle, 0, 0);

    if (bitmap == NULL)
    {
		printf("Error retrieving bitmap data");
		exit(-1);
    }

    if (GetObject(bitmap, sizeof(BITMAP), &m_generalBitmapInfo) == 0)
    {
        printf("BitmapInfo is NULL\n");
		exit(-1);
    }

    unsigned int numberOfFrames = ggGetFrameCount(m_galeFileHandle);
	m_frames.resize(numberOfFrames);

    for (DWORD loop = 0; loop < numberOfFrames; loop++)
    {
		GGAnimationFrame& frame = m_frames[loop];

		frame.Init(loop, 
                   m_galeFileHandle, 
                   m_tileStore, 
                   m_options, 
                   m_animationProperties);

		m_totalFrameTime += frame.GetFrameDelayTime();
    }
}

void GGAnimation::Write(const std::string& outputFolder, const std::string& outputName)
{
	WriteGGAnimationHeaderFile(outputFolder, outputName);
	WriteGGAnimationSourceFile(outputFolder, outputName);
}

void GGAnimation::WriteGGAnimationHeaderFile(const std::string& outputFolder, const std::string& outputName)
{
	std::string headerFilename = outputName + ".h";
	std::ofstream headerfile(outputFolder + headerFilename, std::ios::trunc);

    // header guard
    std::string headerGuard = outputName + "_ANIMATION_INCLUDE_H";
    std::transform(headerGuard.begin(), headerGuard.end(), headerGuard.begin(), ::toupper);
    headerfile << "// File generated by gg2c. https://github.com/pw32x/gg2c\n";
    headerfile << "#ifndef " << headerGuard << "\n";
    headerfile << "#define " << headerGuard << "\n";
    headerfile << "\n";

	// includes
    headerfile << "#include \"animation_types.h\"\n";
    headerfile << "\n";

	// exported types

    if (m_options.mSMSBatchedSprites)
        headerfile << "extern const AnimationBatched " << outputName << ";\n"; 
    else
        headerfile << "extern const Animation " << outputName << ";\n"; 


    headerfile << "\n";

    // end header guard
    headerfile << "#endif\n\n";
    headerfile.close();
}

void WriteToFourBytes(char value, char shift, BYTE bytes[4])
{
    bytes[0] |= ((value & 0x01) >> 0) << shift;
    bytes[1] |= ((value & 0x02) >> 1) << shift;
    bytes[2] |= ((value & 0x04) >> 2) << shift;
    bytes[3] |= ((value & 0x08) >> 3) << shift;
}

void ConvertToPlanar(int row, const BYTE* tileData, BYTE bytes[4])
{
    BYTE rowData[8];

    for (int loop = 0; loop < SMS_TILE_WIDTH; loop++)
    {
        BYTE value = tileData[loop + (row * SMS_TILE_WIDTH)];

        rowData[loop] = value;
    }

    for (int loop = 0; loop < 8; loop++)
    {
        WriteToFourBytes(rowData[loop], 7 - loop, bytes);
    }
}

std::string WriteByteAsHex(DWORD value)
{
    std::stringstream tempStringStream;

    tempStringStream << "0x";
    tempStringStream.width(2);
    tempStringStream.fill('0');
    tempStringStream << std::hex << value;

    return tempStringStream.str();
}

void OutputTilePlanar(std::ofstream& sourceFile, const Tile& tile)
{
    for (int row = 0; row < SMS_TILE_HEIGHT; row++)
    {
        BYTE bytes[4];
        memset(bytes, 0, sizeof(bytes));
        ConvertToPlanar(row, tile.data(), bytes);

        sourceFile << "    ";

        for (int loop = 0; loop < 4; loop++)
        {
            sourceFile << WriteByteAsHex(bytes[loop]) <<", ";
        }

        sourceFile << "\n";
    }
}

void WriteTileStore(const std::string& outputName, std::ofstream& sourceFile, const std::vector<Tile>& tileStore)
{
	std::string outputTileDataName = outputName + "TileData";

    int tileIndex = 0;
    int totalTiles = 0;
    sourceFile << "unsigned char const " << outputTileDataName << "[" << tileStore.size() * 32 << "] = // " << tileStore.size() << "tiles x " << "32 bytes" << "\n";
    sourceFile << "{\n";

	int tileCount = 0;

    for (const auto& tile : tileStore)
    {
        sourceFile << "// tile: " << tileCount << "\n";
		tileCount++;

        OutputTilePlanar(sourceFile, tile);
    }

    sourceFile << "};\n\n";
}

// TODO
// Write block of Y first, then block of XN
// write sprites as one big block. frames have index into it.
void GGAnimation::WriteSprites(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGAnimationFrame& frame = m_frames[frameLoop];

        std::string spriteName = BuildFrameName(outputName, frameLoop) + "Sprites";

        sourceFile << "const AnimationSprite " << spriteName << "[] = \n";
        sourceFile << "{\n";

        for (const auto& sprite : frame.getSprites())
        {
            sourceFile << "    { ";
            sourceFile << sprite.xPositionOffset - m_animationProperties.mOffsetX << ", ";
            sourceFile << sprite.yPositionOffset - m_animationProperties.mOffsetY << ", ";
            sourceFile << sprite.tileStoreIndex;
            sourceFile << " },\n";
        }

        sourceFile << "};\n\n";
    }
}

void GGAnimation::WriteSpritesBatched(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGAnimationFrame& frame = m_frames[frameLoop];

        std::string spriteName = BuildFrameName(outputName, frameLoop) + "SpriteBatched";

        sourceFile << "const AnimationSpriteBatched " << spriteName << "[] = \n";
        sourceFile << "{\n";

        for (const auto& adjoiningSprite : frame.getAdjoiningSprites())
        {
            sourceFile << "    { ";
            sourceFile << adjoiningSprite.adjoiningCount << ", ";
            sourceFile << "{ ";
            sourceFile << adjoiningSprite.sprite->xPositionOffset - m_animationProperties.mOffsetX << ", ";
            sourceFile << adjoiningSprite.sprite->yPositionOffset - m_animationProperties.mOffsetY << ", ";
            sourceFile << adjoiningSprite.sprite->tileStoreIndex;
            sourceFile << " }";
            sourceFile << " },\n";
        }
        sourceFile << "    {0},\n";
        sourceFile << "};\n\n";
    }
}

void GGAnimation::WriteFramesBatched(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGAnimationFrame& frame = m_frames[frameLoop];

        std::string frameName = BuildFrameName(outputName, frameLoop);

		sourceFile << "\n";
		sourceFile << "const AnimationFrameBatched " << frameName << " = \n";
		sourceFile << "{\n";
        sourceFile << "    " << frameName << "SpriteBatched,\n";
		sourceFile << "    " << frame.GetFrameDelayTime() << ", // frame time\n"; 
		sourceFile << "};\n";
	}
}


void GGAnimation::WriteFrames(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGAnimationFrame& frame = m_frames[frameLoop];

        std::string frameName = BuildFrameName(outputName, frameLoop);

		sourceFile << "\n";
		sourceFile << "const AnimationFrame " << frameName << " = \n";
		sourceFile << "{\n";
        sourceFile << "    " << frameName << "SpriteBatch,\n";
		sourceFile << "    " << frame.getSprites().size() << ", // number of sprites\n";
		sourceFile << "    " << frame.GetFrameDelayTime() << ", // frame time\n"; 
		sourceFile << "};\n";
	}
}

void GGAnimation::WriteFrameArrayBatched(const std::string& outputName, std::ofstream& sourceFile)
{
    sourceFile << "const AnimationFrameBatched* const " << outputName << "Frames[" << m_frames.size() << "] = \n";
    sourceFile << "{\n";

    for (size_t loop = 0; loop < m_frames.size(); loop++)
    {
        sourceFile << "    &" << BuildFrameName(outputName, loop) << ",\n";
    }

    sourceFile << "};\n\n";
}


void GGAnimation::WriteFrameArray(const std::string& outputName, std::ofstream& sourceFile)
{
    sourceFile << "const AnimationFrame* const " << outputName << "Frames[" << m_frames.size() << "] = \n";
    sourceFile << "{\n";

    for (size_t loop = 0; loop < m_frames.size(); loop++)
    {
        sourceFile << "    &" << BuildFrameName(outputName, loop) << ",\n";
    }

    sourceFile << "};\n\n";
}


void GGAnimation:: WriteAnimationStructBatched(const std::string& outputName, std::ofstream& sourceFile)
{
    // final struct
    sourceFile << "const AnimationBatched " << outputName << " = \n";
    sourceFile << "{\n";
    sourceFile << "    (const AnimationFrameBatched** const)" << outputName << "Frames,\n";
    sourceFile << "    (unsigned char* const)" << outputName << "TileData, // start of the sprite data\n";
	sourceFile << "    " << m_totalFrameTime << ", // the total time of the animation\n";
    sourceFile << "    " << m_frames.size() << ", // number of frames\n";
    sourceFile << "    " << m_generalBitmapInfo.bmWidth << ", // width in pixels\n";
    sourceFile << "    " << m_generalBitmapInfo.bmHeight << ", // height in pixels\n";
    sourceFile << "    " << m_tileStore.size() << ", // the total amount of tiles in animation\n";

    sourceFile << "};\n";
}


void GGAnimation:: WriteAnimationStruct(const std::string& outputName, std::ofstream& sourceFile)
{
    // final struct
    sourceFile << "const Animation " << outputName << " = \n";
    sourceFile << "{\n";
    sourceFile << "    (const AnimationFrame** const)" << outputName << "Frames,\n";
    sourceFile << "    (unsigned char* const)" << outputName << "TileData, // start of the sprite data\n";
	sourceFile << "    " << m_totalFrameTime << ", // the total time of the animation\n";
    sourceFile << "    " << m_frames.size() << ", // number of frames\n";
    sourceFile << "    " << m_generalBitmapInfo.bmWidth << ", // width in pixels\n";
    sourceFile << "    " << m_generalBitmapInfo.bmHeight << ", // height in pixels\n";
    sourceFile << "    " << m_tileStore.size() << ", // the total amount of tiles in animation\n";

    sourceFile << "};\n";
}


void GGAnimation::WriteGGAnimationSourceFile(const std::string& outputFolder, const std::string& outputName)
{
	std::ofstream sourceFile(outputFolder + outputName + ".c");

    // includes
    sourceFile << "#include \"" << outputName << ".h\"\n";
	
    sourceFile << "\n";
    sourceFile << "\n";

	// tile data
	WriteTileStore(outputName, sourceFile, m_tileStore);

    if (m_options.mSMSBatchedSprites)
    {
        WriteSpritesBatched(outputName, sourceFile);
        WriteFramesBatched(outputName, sourceFile);
	    WriteFrameArrayBatched(outputName, sourceFile);
        WriteAnimationStructBatched(outputName, sourceFile);
    }
    else
    {
        WriteSprites(outputName, sourceFile);
	    WriteFrames(outputName, sourceFile);
        WriteFrameArray(outputName, sourceFile);
        WriteAnimationStruct(outputName, sourceFile);
    }

    sourceFile.close();
}

/*
#include "player.h"


unsigned short const playerTileData[32] = 
{
// tile: 0
    0x0000, 0x22,
    0x0000, 0x2ee,
    0x0000, 0x2eee,
    0x0000, 0x29e9,
    0x0002, 0x9ee6,
    0x0002, 0xee66,
    0x002e, 0xfe6e,
    0x002e, 0xfe9c,

	[...]

};

const Sprite playerFrame0Sprites[] =
{
	x, y, n,
	x, y, n,
	[...]
};

const Sprite playerFrame0XFlippedSprites[] =
{
	x, y, n,
	x, y, n,
	[...]
};

(align to 4)
const AnimationFrame playerFrame0 =
{
	playerFrame0Sprites
	0, // frame time
	X, // num sprites
}

(align to 4)
const AnimationFrame playerFrame0XFlipped =
{
	playerFrame0XFlippedSprites
	0, // frame time
	X, // num sprites

}

const AnimationFrames* playerFrames[] = // need pointers???
{
	playerFrame0,
	playerFrame0XFlipped
};

(align to 4)
const Animation player_animation =
{
    playerFrames,										(unsigned int)
    (u32*)playerTileData, // start of the sprite data	(unsigned int)
    2, // number of frames								(unsigned char)
    24, // width in pixels								(unsigned char)
    32, // height in pixels								(unsigned char)
    12, // max tiles per frame							(unsigned char)
    20, // the total number of tiles in the animation	(unsigned char)
    118, // the total time of the animation				(unsigned short)
};



*/

}